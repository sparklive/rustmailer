use std::time::Instant;

use chrono::{DateTime, Utc};
use itertools::Itertools;
use native_db::*;
use native_model::{native_model, Model};
use poem_openapi::Object;
use serde::{Deserialize, Serialize};
use tracing::info;

use crate::{
    calculate_hash, id,
    modules::{
        cache::{
            imap::{
                address::AddressEntity,
                thread::{EmailThread, EmailThreadKey},
            },
            model::Envelope,
            vendor::outlook::model::{Message, Recipient},
        },
        common::Addr,
        database::{
            batch_delete_impl, manager::DB_MANAGER, paginate_secondary_scan_impl,
            secondary_find_impl, with_transaction,
        },
        error::{code::ErrorCode, RustMailerError, RustMailerResult},
        rest::response::DataPage,
        utils::envelope_hash_from_id,
    },
    raise_error,
};

#[derive(Clone, Debug, Default, Eq, PartialEq, Deserialize, Serialize, Object)]
#[native_model(id = 11, version = 1)]
#[native_db(primary_key(pk -> String), secondary_key(create_envelope_id -> u64, unique))]
pub struct OutlookEnvelope {
    /// The ID of the account owning this email within RustMailer.
    /// This corresponds to the local RustMailer account ID, not the Gmail account itself.
    #[secondary_key]
    pub account_id: u64,
    /// The unique internal identifier of the folder within RustMailer’s local cache,
    /// generated by hashing the combination of `account_id` and the remote Outlook folder ID.
    ///
    /// This ensures a consistent, collision-free mapping between each Outlook folder
    /// and its corresponding local representation.
    ///
    /// Note: this is **not** the original Outlook folder ID; it is derived locally.
    #[secondary_key]
    pub folder_id: u64,
    /// The human-readable name of the Outlook folder where the email resides.
    ///
    /// This corresponds to the folder’s display name (e.g., “Inbox”, “Sent Items”)
    /// as provided by Microsoft Graph.
    pub folder_name: String,
    /// The Outlook message ID as returned by the Microsoft Graph `messages` API.
    ///
    /// This ID uniquely identifies the email within the user’s mailbox and remains
    /// stable across sync operations.
    pub id: String,
    /// The date and time when Outlook received or created the email, represented
    /// as a Unix timestamp in milliseconds.
    ///
    /// Corresponds to the Microsoft Graph API field `receivedDateTime`.
    /// May be `None` if the value is unavailable.
    pub internal_date: Option<i64>,
    /// The estimated size of the email in bytes.
    ///
    /// This is calculated locally as the sum of the email body length in bytes
    /// plus the total size of all attachments. It serves as an approximate value
    /// for storage and syncing purposes.
    pub size: u32,
    /// Blind carbon copy (BCC) recipient(s), if any. Each `Addr` contains name and email.
    pub bcc: Option<Vec<Addr>>,
    /// Carbon copy (CC) recipient(s), if any. Each `Addr` contains name and email.
    pub cc: Option<Vec<Addr>>,
    /// The date and time when the email was sent, as a Unix timestamp in milliseconds.
    ///
    /// Extracted from the `sentDateTime` field from Microsoft Graph if available,
    /// or from the `Date` header in the message metadata. May be `None` if the value
    /// is missing or cannot be parsed.
    pub date: Option<i64>,
    /// The sender's address, as specified in the `From` header.
    pub from: Option<Addr>,
    /// The message ID of the email to which this email is a reply, if applicable.
    /// Corresponds to the `In-Reply-To` header.
    pub in_reply_to: Option<String>,
    /// The actual sender's address, if different from the `From` field.
    /// Extracted from the `Sender` header, if present.
    pub sender: Option<Addr>,
    /// The globally unique message ID of the email.
    ///
    /// Extracted from the `Message-ID` header in the email. This value is useful
    /// for threading, deduplication, and correlating messages across different
    /// mailboxes or systems.
    pub message_id: Option<String>,
    /// The subject of the email, if present.
    pub subject: Option<String>,
    /// The identifier of the thread (conversation) this email belongs to.
    ///
    /// Since Microsoft Graph API does not reliably provide `references` or `inReplyTo`
    /// for all messages, this value is generated locally by hashing the `conversationId`
    /// from Graph API. This ensures a consistent and unique thread ID for all messages
    /// within the same conversation.
    #[secondary_key]
    pub thread_id: u64,
    /// The MIME version of the email (e.g., "1.0").
    ///
    /// Currently always `None` because Microsoft Graph API does not expose the
    /// `Mime-Version` header, and some emails may lack complete raw headers.
    pub mime_version: Option<String>,

    /// List of message IDs referenced by this email, used for threading.
    ///
    /// Currently always `None` because Microsoft Graph API does not reliably provide
    /// the `References` header, and some emails may not include full header information.
    pub references: Option<Vec<String>>,
    /// The address(es) to which replies should be sent, if specified.
    /// Corresponds to the `Reply-To` header.
    pub reply_to: Option<Vec<Addr>>,
    /// Primary recipient(s) of the email, corresponding to the `To` header.
    pub to: Option<Vec<Addr>>,
    /// A short snippet (preview) of the email body.
    ///
    /// Corresponds to the Microsoft Graph API `bodyPreview` field. Typically contains
    /// the first few hundred characters of the message body, useful for display
    /// in lists or notifications.
    pub snippet: Option<String>,
    /// The Outlook conversation (thread) ID associated with this email.
    ///
    /// Corresponds to the Microsoft Graph `conversationId` field. All messages
    /// within the same conversation share the same value.
    pub conversation_id: Option<String>,

    /// A list of categories (labels) applied to the message.
    ///
    /// Each element is a string representing an Outlook category name. This field
    /// reflects the current categories assigned to the email in Outlook.
    pub categories: Vec<String>,

    pub is_read: bool,
}

impl OutlookEnvelope {
    pub fn pk(&self) -> String {
        format!(
            "{}_{}",
            self.internal_date.unwrap_or_default(),
            envelope_hash_from_id(self.account_id, self.folder_id, &self.id)
        )
    }

    pub fn create_envelope_id(&self) -> u64 {
        envelope_hash_from_id(self.account_id, self.folder_id, &self.id)
    }

    pub async fn exists(&self) -> RustMailerResult<bool> {
        let target = secondary_find_impl::<OutlookEnvelope>(
            DB_MANAGER.envelope_db(),
            OutlookEnvelopeKey::create_envelope_id,
            self.create_envelope_id(),
        )
        .await?;
        Ok(target.is_some())
    }

    pub async fn list_messages_in_folder(
        folder_id: u64,
        page: u64,
        page_size: u64,
        desc: bool,
    ) -> RustMailerResult<DataPage<OutlookEnvelope>> {
        paginate_secondary_scan_impl(
            DB_MANAGER.envelope_db(),
            Some(page),
            Some(page_size),
            Some(desc),
            OutlookEnvelopeKey::folder_id,
            folder_id,
        )
        .await
        .map(DataPage::from)
    }

    pub async fn clean_account(account_id: u64) -> RustMailerResult<()> {
        const BATCH_SIZE: usize = 200;
        let mut total_deleted = 0usize;
        let start_time = Instant::now();
        loop {
            let deleted = batch_delete_impl(DB_MANAGER.envelope_db(), move |rw| {
                let to_delete: Vec<OutlookEnvelope> = rw
                    .scan()
                    .secondary(OutlookEnvelopeKey::account_id)
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                    .start_with(account_id)
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                    .take(BATCH_SIZE)
                    .try_collect()
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?;
                Ok(to_delete)
            })
            .await?;
            total_deleted += deleted;
            // If this batch is empty, break the loop
            if deleted == 0 {
                break;
            }
        }

        info!(
            "Finished deleting outlook envelopes for account_id={} total_deleted={} in {:?}",
            account_id,
            total_deleted,
            start_time.elapsed()
        );
        Ok(())
    }

    pub async fn clean_folder_envelopes(account_id: u64, folder_id: u64) -> RustMailerResult<()> {
        const BATCH_SIZE: usize = 200;
        let mut total_deleted = 0usize;
        let start_time = Instant::now();
        loop {
            let deleted = batch_delete_impl(DB_MANAGER.envelope_db(), move |rw| {
                let to_delete: Vec<OutlookEnvelope> = rw
                    .scan()
                    .secondary(OutlookEnvelopeKey::folder_id)
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                    .start_with(folder_id)
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                    .filter_map(Result::ok) // filter only Ok values
                    .filter(|e: &OutlookEnvelope| e.account_id == account_id)
                    .take(BATCH_SIZE)
                    .collect();
                Ok(to_delete)
            })
            .await?;
            total_deleted += deleted;
            // If this batch is empty, break the loop
            if deleted == 0 {
                break;
            }
        }

        info!(
            "Finished deleting outlook envelopes for folder_id={} account_id={} total_deleted={} in {:?}",
            folder_id,
            account_id,
            total_deleted,
            start_time.elapsed()
        );
        Ok(())
    }

    pub async fn save_envelopes(envelopes: Vec<OutlookEnvelope>) -> RustMailerResult<()> {
        with_transaction(DB_MANAGER.envelope_db(), move |rw| {
            for e in envelopes {
                let envelope_id = e.create_envelope_id();
                // Idempotent write
                if rw
                    .get()
                    .secondary::<OutlookEnvelope>(
                        OutlookEnvelopeKey::create_envelope_id,
                        envelope_id,
                    )
                    .map_err(|err| raise_error!(format!("{:#?}", err), ErrorCode::InternalError))?
                    .is_none()
                {
                    rw.insert::<OutlookEnvelope>(e.clone()).map_err(|err| {
                        raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                    })?;

                    let address_entities = AddressEntity::extract3(&e);
                    let thread = EmailThread::new(
                        e.thread_id,
                        envelope_id,
                        e.account_id,
                        e.folder_id,
                        e.internal_date,
                        e.date,
                    );
                    // --- Thread upsert ---
                    match rw
                        .get()
                        .secondary::<EmailThread>(EmailThreadKey::thread_id, thread.thread_id)
                        .map_err(|err| {
                            raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                        })? {
                        Some(current) => {
                            // Only replace if current.internal_date is older than new internal_date
                            if current.need_update(&thread) {
                                rw.remove(current).map_err(|err| {
                                    raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                                })?;
                                rw.insert::<EmailThread>(thread).map_err(|err| {
                                    raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                                })?;
                            }
                        }
                        None => {
                            rw.insert::<EmailThread>(thread).map_err(|err| {
                                raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                            })?;
                        }
                    }

                    // --- Store address entities ---
                    for addr in address_entities {
                        rw.insert::<AddressEntity>(addr).map_err(|err| {
                            raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                        })?;
                    }
                } else {
                    rw.upsert::<OutlookEnvelope>(e.clone()).map_err(|err| {
                        raise_error!(format!("{:#?}", err), ErrorCode::InternalError)
                    })?;
                }
            }
            Ok(())
        })
        .await
    }
}

impl TryFrom<Message> for OutlookEnvelope {
    type Error = RustMailerError;

    fn try_from(msg: Message) -> Result<Self, Self::Error> {
        fn parse_datetime(dt: &Option<String>) -> RustMailerResult<Option<i64>> {
            dt.as_ref()
                .map(|s| {
                    s.parse::<DateTime<Utc>>()
                        .map(|dt| dt.timestamp_millis())
                        .map_err(|e| {
                            raise_error!(
                                format!("Invalid datetime {}: {}", s, e),
                                ErrorCode::InternalError
                            )
                        })
                })
                .transpose()
        }

        fn recipient_to_addr(r: &Option<Recipient>) -> Option<Addr> {
            r.as_ref().map(|r| Addr {
                name: r.email_address.name.clone(),
                address: r.email_address.address.clone(),
            })
        }

        fn recipients_to_addrs(rs: &Option<Vec<Recipient>>) -> Option<Vec<Addr>> {
            rs.as_ref().map(|v| {
                v.iter()
                    .map(|r| Addr {
                        name: r.email_address.name.clone(),
                        address: r.email_address.address.clone(),
                    })
                    .collect()
            })
        }
        let internal_date = parse_datetime(&msg.received_date_time)?;
        let date = parse_datetime(&msg.sent_date_time)?;
        let body_len = msg
            .body
            .as_ref()
            .and_then(|b| b.content.as_ref())
            .map(|s| s.len())
            .unwrap_or(0);
        let attachments_size: usize = msg
            .attachments
            .as_ref()
            .map(|atts| atts.iter().map(|a| a.size.unwrap_or(0) as usize).sum())
            .unwrap_or(0);
        let size = (body_len + attachments_size) as u32;

        let thread_id = match &msg.conversation_id {
            Some(conversation_id) => calculate_hash!(conversation_id),
            None => id!(128),
        };

        Ok(OutlookEnvelope {
            account_id: 0,
            folder_id: 0,
            folder_name: "".to_string(),
            id: msg.id,
            internal_date,
            size,
            bcc: recipients_to_addrs(&msg.bcc_recipients),
            cc: recipients_to_addrs(&msg.cc_recipients),
            date: date,
            from: recipient_to_addr(&msg.from),
            in_reply_to: None,
            sender: recipient_to_addr(&msg.sender),
            message_id: msg.internet_message_id.as_ref().map(|s| {
                s.strip_prefix('<')
                    .and_then(|s| s.strip_suffix('>'))
                    .unwrap_or(s)
                    .to_string()
            }),
            subject: msg.subject.clone(),
            thread_id,
            mime_version: None,
            references: None,
            reply_to: recipients_to_addrs(&msg.reply_to),
            to: recipients_to_addrs(&msg.to_recipients),
            snippet: msg.body_preview.clone(),
            conversation_id: msg.conversation_id.clone(),
            categories: msg.categories.clone().unwrap_or_default(),
            is_read: msg.is_read.unwrap_or_default(),
        })
    }
}

impl From<OutlookEnvelope> for Envelope {
    fn from(value: OutlookEnvelope) -> Self {
        Self {
            id: value.id,
            account_id: value.account_id,
            mailbox_id: value.folder_id,
            mailbox_name: value.folder_name,
            internal_date: value.internal_date,
            size: value.size,
            flags: None,
            flags_hash: None,
            bcc: value.bcc,
            cc: value.cc,
            date: value.date,
            from: value.from,
            in_reply_to: value.in_reply_to,
            sender: value.sender,
            return_address: None,
            message_id: value.message_id,
            subject: value.subject,
            thread_name: None,
            thread_id: value.thread_id,
            mime_version: value.mime_version,
            references: value.references,
            reply_to: value.reply_to,
            to: value.to,
            attachments: None,
            body_meta: None,
            received: None,
            labels: value.categories,
            is_read: value.is_read,
        }
    }
}
